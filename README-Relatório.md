# Simulation-WaveFront
O relatório do trabalho prático 02, tem como objetivo explicar e exemplificar o funcionamento do programa desenvolvido, mais especificamente os métodos públicos da classe Matriz, sendo eles o CriaMapa(), o WaveFront() e o Simulacao() que juntos retratam, de maneira geral, um mapa com um um ponto de partida e um ponto de chegada no qual é traçado um caminho entre os vértices, que podem estar sendo interrompidos parcialmente/totalmente por barreiras. 
Como forma de representar o grid, utilizei a estrutura de dados HashMap e uma variável do tipo int. A tabela hash foi responsável por guardar os elementos importantes do grid, ou seja, as barreiras, o robô e o destino do robô. Enquanto, a variável int por delimitar seus limites, ou seja, a ordem quadrática da matriz. Tanto a estrutura do tipo hash, denominada elementos, quanto a variável do tipo int, intitulada como limite, foram declaradas como globais, a fim de facilitar o processo de animação.
A chave escolhida para a estrutura hash foi a classe Cordenada desenvolvida para guardar a informação dos pontos i e j do array bidimensional. Já os valores de cada key são inteiros que respeitam as atribuições (número → elemento) feitas pelo professor, como exemplo o fato do número 0 representar obstáculos no grid.

Métodos desenvolvidos
	Como dito anteriormente, os métodos foram criados na classe Matriz. Assim, para a execução do programa é necessário a criação de uma variável do tipo Matriz, para tal é necessário a passagem da ordem do grid desejado (o limite) como parâmetro no construtor da classe.


CriaMapa()
	O método criaMapa() é responsável por determinar as posições dos elementos especiais no grid, que após definição do objeto só apresenta espaços vazios (elementos.isEmpty() == true → matriz inicializada com -1). Para tal realiza a chamada de outras três funções: 
A função determina_barreiras() roda um laço while, que para, quando o número de barreiras escolhidas (por meio de uma variável global) são inseridos no mapa - de forma a não repetirem uma mesma posição -.
A cada interação é criada uma nova coordenada do tipo Coordenada que recebem um i e j randômicos (que respeitam os limites do grid) a partir dos objetos Xgerador e Ygerador, do tipo Random. Então, caso a nova chave não esteja presente no HashMap, ela é inserida na estrutura, juntamente, com o valor definido para as barreiras. Por fim, ainda dentro da estrutura condicional a variável responsável pela parada do while (int acumulador, inicialmente, zerada) é incrementada.
	A função determina_robo() e determina_destino() operam de maneira igual, apenas trocando o valor a ser atribuído por sua respectiva chave no HashMap.
	Consistem em um laço while que tem como condição uma variável do tipo booleana inicializada com true (chave_existencia = true). Nesse sentido, dentro da estrutura de repetição, uma variável do tipo Coordenada é inicializada, recebendo como parâmetros números randômicos limitados de acordo com o tamanho do grid. Então, uma nova atribuição é feita sobre a chave_existencia, que recebe o retorno do método containsKey(), retornando true caso a chave já exista no hash e falso caso o contrário.
	Caso a coordenada já esteja no mapa representando um elemento especial  o laço continue. Agora, se a coordenada não exista no mapa, o laço se encerra e a coordenada é inserida no HashMap com o valor que representa o robo/destino.

BFS()
O método BFS() é responsável por avançar as fronteiras do robô até chegar ao destino ou não ter mais como prosseguir. Faz isso percorrendo os vértices adjacentes válidos de uma posição foco, que inicialmente é a coordenada do robô e ao longo da operação vai mudando até chegar ao destino ou em uma situação onde não há mais vértices válidos, assim, parando a operação.
Para exercer essa funcionalidade, o código conta com uma lista encadeada, denominada adjacentes, que funciona como uma fila e guarda a coordenada dos vértices adjacentes bem como seus respectivos valores. O primeiro ponto a ser colocado na fila é o robô que recebe como peso o número 0, já que a ideia é progressivamente ir acrescentando 1 ao valor dos adjacentes, acompanhando o número de sua fronteira.
Essa progressão é feita dentro de uma laço while, condicionado para parar quando a lista de adjacentes ficar vazia (caminho não encontrado) ou quando o destino for achado. Nesse sentido, em cada execução da estrutura de repetição o primeiro elemento da lista de adjacentes é armazenado em uma variável auxiliar e então removido da fila. Após esse processo, por meio de outra estrutura de repetição (for) os vértices adjacentes à variável auxiliar são analisados, passando por duas estruturas condicionais. A primeira avalia se a posição adjacente em questão é o destino, caso seja, o programa constata que foi possível achar um caminho do robô ao destino e a operação é interrompida. Já, a segunda avalia se a posição é válida (ou seja, está dentro dos limites e ausente do HashMap), sendo verdadeira essa condição o vértice é adicionado à lista de adjacentes e também ao HashMap, lembrando de acrescentar um ao seu valor, em relação ao número da fronteira anterior. 
WaveFront()
O método WaveFront() é responsável por gerar o melhor caminho entre o robô e o destino. Primeiramente, chama a função BFS(), que como dito anteriormente, gera o aumento gradual entre o valor das fronteiras,  que têm como início a posição do robô e fim a fronteira do destino ou uma fronteira sem mais vértices válidos. Posteriormente, levando em consideração a progressão do código, que ocorre quando a ligação robô-destino é possível, é criada novamente uma lista de adjacentes que agora chega a guardar no máximo 4 vértices que são renovados a cada iteração do laço while, responsável por pegar os vértices adjacentes válidos de uma posição foco (última coordenada colocada na lista) e dentre eles adicionar a LinkedList melhor_caminho, que funciona como uma pilha, aquele que apresenta o menor valor, fazendo da posição do destino até uma posição adjacente corresponda ao robô que será o último elemento adicionado à pilha e portanto o primeiro a sair dela.

OBS: apesar de não conseguirmos ver, aqui o programa já sabe o melhor caminho entre o Yoda e o Darth Vader.

Simulacao()
	O método Simulacao() é responsável por fazer o robô se locomover no grid criado na função draw e promover uma sinalização para a situação em que o caminho foi encontrado e aquele que não foi possível tal feito. Como dito anteriormente, na função BFS() o programa fica ciente da conectividade entre o robô e o destino, assim, caso haja caminho o método utiliza a pilha, para ir mudando a posição do robô de acordo com as coordenadas inseridas, imprimir no console que o caminho foi encontrado. Caso o caminho não seja encontrado o programa imprime essa informação. Além disso, por meio de uma variável global do tipo color, o programa muda a coloração de fundo das barreiras de acordo com a situação apresentada.
Verde = caminho encontrado;
Vermelho = caminho não encontrado.
